import { Draft, CreateDraftInput, Revision, Change } from '@contentpipe/types';
import { prisma } from '../../infrastructure/database/prisma';
import { NotFoundError, ValidationError } from '../../shared/errors/error-handler';
import { ProjectService } from '../projects/project.service';

export class DraftService {
  private projectService = new ProjectService();

  async listByProject(projectId: string, userId: string): Promise<Draft[]> {
    await this.projectService.getById(projectId, userId);

    const drafts = await prisma.draft.findMany({
      where: { projectId },
      orderBy: { versionNumber: 'desc' },
    });

    return drafts.map(this.mapDraftToDomain);
  }

  async getById(draftId: string, userId: string): Promise<Draft> {
    const draft = await prisma.draft.findFirst({
      where: { id: draftId },
      include: { project: true },
    });

    if (!draft || draft.project.userId !== userId) {
      throw new NotFoundError('Draft', draftId);
    }

    return this.mapDraftToDomain(draft);
  }

  async generate(projectId: string, userId: string): Promise<Draft> {
    const project = await this.projectService.getById(projectId, userId);

    // TODO: Get processed sources
    // TODO: Call LLM to generate draft
    // TODO: Generate outline and citations

    const versionNumber = project.versionCount + 1;

    const draft = await prisma.draft.create({
      data: {
        projectId,
        versionNumber,
        content: 'Draft content will be generated by AI...',
        outline: { sections: [] },
        citations: [],
        qualityScore: 0,
        generationTime: 0,
        parentDraftId: project.currentVersionId,
      },
    });

    // Update project
    await prisma.project.update({
      where: { id: projectId },
      data: {
        versionCount: versionNumber,
        currentVersionId: draft.id,
        status: 'draft',
      },
    });

    return this.mapDraftToDomain(draft);
  }

  async refine(
    draftId: string,
    userId: string,
    feedback: string,
    feedbackType: string
  ): Promise<Revision> {
    const draft = await this.getById(draftId, userId);

    // TODO: Call refinement engine
    // TODO: Generate alternatives
    // TODO: Apply changes

    const revision = await prisma.revision.create({
      data: {
        draftId,
        feedback,
        feedbackType,
        changeSummary: 'Refinement applied',
        alternativesGenerated: 1,
        alternativeSelected: 0,
        intentPreserved: true,
      },
    });

    return this.mapRevisionToDomain(revision);
  }

  async export(
    projectId: string,
    userId: string,
    format: string,
    includeCitations?: boolean
  ): Promise<{ content: string; format: string }> {
    const project = await this.projectService.getById(projectId, userId);

    if (!project.currentVersionId) {
      throw new ValidationError('No draft available for export');
    }

    const draft = await this.getById(project.currentVersionId, userId);

    // TODO: Format based on requested format (markdown, docx, html, pdf)
    
    return {
      content: draft.content,
      format,
    };
  }

  private mapDraftToDomain(draft: any): Draft {
    return {
      id: draft.id,
      projectId: draft.projectId,
      versionNumber: draft.versionNumber,
      content: draft.content,
      outline: draft.outline,
      citations: draft.citations,
      qualityScore: draft.qualityScore,
      generationTime: draft.generationTime,
      createdAt: draft.createdAt,
      parentDraftId: draft.parentDraftId,
    };
  }

  private mapRevisionToDomain(revision: any): Revision {
    return {
      id: revision.id,
      draftId: revision.draftId,
      feedback: revision.feedback,
      feedbackType: revision.feedbackType,
      changeSummary: revision.changeSummary,
      alternativesGenerated: revision.alternativesGenerated,
      alternativeSelected: revision.alternativeSelected,
      intentPreserved: revision.intentPreserved,
      changesApplied: [],
      createdAt: revision.createdAt,
    };
  }
}
